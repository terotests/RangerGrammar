{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../test/parser.ts"],"names":[],"mappings":"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","sourcesContent":["// npm install @types/chai @types/mocha --save-dev\nimport 'mocha';\nimport { expect } from 'chai' \n\nimport { ParserBuffer  } from '../src/astparsers/buffer'\nimport { WalkRule, WalkRuleSet, ParsingRule } from '../src/rules/walker'\nimport {detectorFn, createDetector} from '../src/astparsers/detector'\nimport { ASTNode } from '../src/ast/ast';\n// const expect  = require(\"chai\").expect;\n\nconst equal_signs = [\n  '<', '>', '===', '==', '<=', '>='\n]\nconst statements = [\n  'for', 'while', 'if','then'\n]\nconst keywords = [\n  'class', 'function', 'extends', 'static'\n]\n\n// simple detector\nconst plusOperator = createDetector(['+'])\n\n// how to create operator from that?\n\n\nconst isComparator = createDetector(equal_signs)\nconst isStatement = createDetector(statements)\nconst isKeyword = createDetector(keywords)\n\nconst is_space =WalkRule.createNamedType( 'space',  buff => buff.getSpace() ).forget()\n\nconst is_numeric = WalkRule.createNamedType( 'number',\n buff => buff.getWhile( buff => {\n  const c = buff.here()\n  const zero = '0'.charCodeAt(0)\n  const nine = '9'.charCodeAt(0)\n  return (c >= zero) && (c <= nine)\n}))\n\ndescribe(\"Test simple parser\", function() {\n\n  it('Simple Expr', ()=> {\n\n    // operator could start the collection of items...\n    // maybe you always create operator...\n\n    /*\n\n4 + 5 * 10    \n\n\n\n    */\n\n    const plus_op = WalkRule.operator('+', 13, 1)\n    const mul_op = WalkRule.operator('*', 14, 1)\n    const buff = new ParserBuffer([`\n      12345 + 17 * 10\n    `])  \n    // spaces and numbers are OK...\n    const startRuleSet = WalkRuleSet.create('std', \n    [\n      is_space,\n      is_numeric,\n      plus_op,\n      mul_op,\n    ])  \n    const firstExpression = WalkRule.create( (buff)=>{\n      const n = new ASTNode()\n      n.expression = true \n      return n\n    })    \n    firstExpression.ruleset = startRuleSet\n    const e = buff.walkRule( firstExpression )\n    console.log(e.getCodeString())\n  })\n\n  it('Sub Expr', ()=> {\n    const buff = new ParserBuffer([`\n      12345 { 4 5 } 4444\n    `])  \n    // spaces and numbers are OK...\n\n    // Here, some small problem, how to allow recursion?\n\n    // Maybe we could crate the rule using name ? \n    // 'RuleBraces' ->\n    // then refer to it recursively...\n\n    /*\n\n    Extendable rule:\n      rule1 <contents> <namedpart2>\n\n    */\n\n    // And where to insert the subrules in this kind of situation ? \n    let braces_rule = WalkRule.createEnterRule('{', [\n      is_space,\n      is_numeric,\n      // TODO: make possible injecting things to create a rule template...\n      WalkRule.createExitRule('}')\n    ])\n\n    // Then you could take the rule and add things into the rule template\n    // for certain positions if required...\n\n    const startRuleSet = WalkRuleSet.create('std', \n    [\n      is_space,\n      is_numeric,\n      braces_rule      \n    ])  \n\n    const firstExpression = WalkRule.create( (buff)=>{\n      const n = new ASTNode()\n      n.expression = true \n      return n\n    })    \n    firstExpression.ruleset = startRuleSet\n    const e = buff.walkRule( firstExpression )\n    // console.log(e.children[3])\n    // console.log('child count ', e.children.length)\n  })  \n\n  it('Numbers and spaces', ()=> {\n    const buff = new ParserBuffer([`\n      12345\n    `])  \n    // spaces and numbers are OK...\n    const startRule = WalkRuleSet.create('std', \n    [\n      is_space,\n      is_numeric,\n    ])  \n    buff.activeRuleset = startRule\n    const parentNode = new ASTNode()\n    buff.walk( parentNode )  \n    expect(parentNode.children.length).to.equal( 3 )\n    expect(parentNode.children[0].typeName).to.equal('space')\n    expect(parentNode.children[1].typeName).to.equal('number')\n    expect(parentNode.children[2].typeName).to.equal('space')\n  })\n\n  it('Should parse simple rules', ()=> {\n    const buff = new ParserBuffer([`\n      1 2 3 4\n    `])  \n    // spaces and numbers are OK...\n    const startRule = WalkRuleSet.create('std', \n    [\n      is_space,\n      is_numeric,\n    ])  \n    buff.activeRuleset = startRule\n    const parentNode = new ASTNode()\n    buff.walk( parentNode )  \n    expect(parentNode.children.length).to.equal( 9 )\n  })\n\n\n\n  // console.log( parentNode.children )\n\n\n})"]}