{"version":3,"file":"walker.js","sourceRoot":"","sources":["../../../src/rules/walker.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { ASTNode } from '../ast/ast';\nimport { ParserBuffer } from '../astparsers/buffer'\nimport { detectorFn, createDetector } from '../astparsers/detector'\n \nexport class WalkCmd {\n\n  // does this command end the expression?\n  end_expression = false\n  \n  // These could be properties of the node\n  is_expression = false\n  is_block = false\n\n  node:ASTNode\n}\n\nexport interface ParsingRule {\n  matchName?:string\n  walkRule?:WalkRule\n  maxCnt?:number\n  required?:boolean\n}\n\n/*\n  WalkRule.generator( () => {\n    // Example of rule which matches only once...\n    let cnt = 0\n    return WalkRule.create( (buff) => {\n      const matches = is_valid_identifier.exec(buff);\n      if( matches ) {\n        if(cnt++ > 0) {\n          throw 'Can not match two identifiers at class!!! ' + buff.buff.substring( buff.i )\n        }\n        // and set the name for the element...\n        matches.name = 'className'\n        return matches  \n      }\n    })\n  }),\n*/\n// how to create language rules\n\nexport type WalkerFunction = (buff:ParserBuffer) => ASTNode | WalkRule | undefined\n\nexport class WalkRule {\n\n  name = ''\n  typeName = ''\n  scopeName = ''\n\n  // the rule constructor name\n  constructorName = ''\n\n  callback : (rulename:string, buff:ParserBuffer, stepLen:number) => void\n  exec : WalkerFunction\n\n  // if set the rule is constructed using this function\n  ruleGenerator : () => WalkRule | undefined\n  ruleset : WalkRuleSet\n  isRequired = false\n  isSkipped = false\n\n  forget() : WalkRule {\n    this.isSkipped = true \n    return this\n  }\n\n  as(name:string) {\n    this.constructorName = name \n    return this\n  }\n\n  insertAt( position:number, rules:WalkRule[]) : WalkRule {\n    // The rule has some subrules...\n    if(this.ruleset) {\n      let index = position\n      for( let r of rules ) {\n        this.ruleset.walkRules.splice(index++, 0, r)\n      }\n    }\n    return this\n  }\n\n  static create( fn:WalkerFunction) : WalkRule {\n    const n = new WalkRule()\n    n.exec = fn\n    return n\n  }\n\n  static named( name:string ) : WalkRule {\n    const n = new WalkRule()\n    n.constructorName = name\n    return n\n  }  \n\n  // this is a bit messed up, typeName etc.\n  static createNamedType( name:string, fn:WalkerFunction) : WalkRule {\n    const n = new WalkRule()\n    n.typeName = name\n    n.exec = fn\n    return n\n  }  \n\n  static generator( fn:() => WalkRule ) : WalkRule {\n    const n = new WalkRule()\n    n.ruleGenerator = fn\n    return n\n  }  \n\n  // const plusOperator = createDetector(['+'])\n\n  // This does not really work now ;/ \n\n  static try( rule : WalkRule ) : WalkRule {\n    const n = new WalkRule()\n    let buff_index \n    let buff_buff\n    let eof \n    n.exec = (buff:ParserBuffer) => {\n      const orig_buff = buff.save()\n      // OK, we try this rule but it does not need to match...\n      try {\n        // buff.walk()\n        console.log('TRY rule ',buff.i, rule)\n        console.log('at ', buff.buff.substring(buff.i))\n        // The problem is that this is not going to walk the buffer...\n        const res = rule.exec( buff )\n        if(res) {\n          console.log('-- did match try --')\n          console.log(res)\n          return res\n        }\n      } catch(e) {\n        console.log('GOT ERROR!!!') \n        console.log(e)\n      }\n      console.log('RETURNING INDEX TO ', buff.i)\n      buff.restore( orig_buff )\n\n      // return undefined\n      const nop = new ASTNode()\n      nop.nop = true\n      return nop\n    }\n    return n\n  }   \n\n  static createSub( \n      fn:(buff:ParserBuffer) => ASTNode | undefined,\n      ruleset : WalkRuleSet \n    ) : WalkRule {\n    const n = new WalkRule()\n    n.ruleset = ruleset\n    n.exec = fn\n    return n\n  }\n\n  static createEnterRule( startCh:string, ruleset:WalkRule[] ) : WalkRule {\n\n    const does_match = createDetector([startCh])    \n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i )\n      if(i >= 0) {\n        buff.step(startCh.length)\n        const node = new ASTNode()\n        node.expression_name = startCh\n        node.expression = true \n        return node\n      }\n    }\n    const rulez = new WalkRuleSet\n    rulez.walkRules = ruleset\n    endCondition.ruleset = rulez\n    endCondition.name = startCh\n    return endCondition    \n  }  \n\n  static once() : WalkRule {\n    return WalkRule.generator( () => {\n      // Example of rule which matches only once...\n      let cnt = 0\n      return WalkRule.create( (buff) => {\n        if(cnt === 0) {\n          cnt++\n          const node = new ASTNode()\n          node.nop = true\n          return node\n        }\n        const node = new ASTNode()\n        node.end_expression = true \n        return node\n      }) \n    })    \n  }   \n\n  static createExit() : WalkRule {\n\n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      // exit in any case\n      const node = new ASTNode()\n      node.end_expression = true \n      return node\n    }\n    return endCondition\n  }   \n\n  static fail( ) : WalkRule {\n\n    const endCondition = new WalkRule();\n    endCondition.exec = (buff) => {\n      throw 'Fails always'\n    }\n    return endCondition\n  }    \n\n  static createExitRule( endCh:string ) : WalkRule {\n\n    const does_match = createDetector([endCh])    \n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i)\n      if(i >= 0) {\n        buff.step(endCh.length)\n        const node = new ASTNode()\n        node.end_expression = true \n        return node\n      }\n    }\n    return endCondition\n  }    \n\n  // opeator('+',17)\n\n  static operator( token:string, precedence:number, assoc:number ) : WalkRule {\n\n    const does_match = createDetector([token])    \n    const endCondition = new WalkRule();\n\n    // 10 + 30\n    // number <operator> number\n    // --> got reposition the operator...\n\n    // 2 * 4 + 5\n\n    /*\n      \n      2\n      2 *  <- here we find operator...\n\n        -> there is some active operator now...\n\n      2 * 4\n\n    */\n\n    // Exprerssion can be anything...\n    // Operator creates... expression ? \n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i)\n      if(i >= 0) {\n        const node = new ASTNode()\n        node.sp = buff.i \n        node.ep = buff.i + token.length\n        node.buff = buff.buff\n        node.expression_name = token\n        node.operator_pred = precedence\n        node.operator_assoc = assoc\n        buff.step(token.length)\n        return node\n      }\n    }\n    return endCondition\n  }    \n\n  static createTokenRules( list:string[] ) : WalkRule {\n\n    const does_match = createDetector(list)    \n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i)\n      if(i >= 0) {\n        // Token node...\n        const node = new ASTNode()\n        node.sp = buff.i \n        node.ep = buff.i + list[i].length\n        node.buff = buff.buff\n        buff.step(list[i].length)\n        return node\n      }\n    }\n    return endCondition\n  }   \n\n  static rule( rule:ParsingRule ) {\n    return WalkRule.generator( () => {\n      // Example of rule which matches only once...\n      let cnt = 0\n      return WalkRule.create( (buff) => {\n        const matches = rule.walkRule.exec(buff);\n        if( matches ) {          \n          if(rule.maxCnt) {\n            if(cnt++ >= rule.maxCnt) {\n              throw 'Can not match two identifiers at class!!! ' + buff.buff.substring( buff.i )\n            }  \n          }\n          // and set the name for the element...\n          matches.name = rule.matchName\n          return matches  \n        } else {\n          if(rule.required && cnt === 0) {\n            throw 'Required rule ' + rule.matchName+ ' not found!!! ' + buff.buff.substring( buff.i )            \n          }\n        }\n      })\n    })    \n  }\n\n}\n\n// Some rules to apply in ceratain conditions...\nexport class WalkRuleSet {\n  name = ''\n  walkRules:WalkRule[] = []\n  static create( name: string, rules:WalkRule[]) : WalkRuleSet {\n    const o = new WalkRuleSet()\n    o.name = name\n    o.walkRules = rules\n    return o\n  }\n}"]}