{"version":3,"file":"buffer.js","sourceRoot":"","sources":["../../../src/astparsers/buffer.ts"],"names":[],"mappings":"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","sourcesContent":["\n/*\n\nBuffer is created for parsing streams of values and strings.\n\n*/\n\nimport {detectorFn, createDetector} from './detector'\nimport { ASTNode } from '../ast/ast';\nimport { WalkCmd, WalkRule, WalkRuleSet, WalkerFunction } from '../rules/walker'\n\nexport type bufferType = string \n\nexport class ParserBuffer  {\n\n  __len = 0\n  buff_index = 0\n  used_index = 0\n\n  // the current buffer and the index inside it\n  buff:bufferType\n  i = 0\n  eof = false\n\n  buffers:bufferType[]\n  last_finished = null\n\n  in_tagdef = false\n  is_selfclosing = false\n  last_tag_name = ''\n\n  // what is the rulez scope we are walking right now...\n  scopes:string[]\n\n  // The current ruleset to be applied...\n  walkRules:WalkRule[] = []\n\n  // Named rules\n  namedRulez:{[key:string]:WalkRuleSet} = {}\n\n  // What is the ruleset to use...\n  rulez:WalkRuleSet[] = []\n\n  // Active ruleset...\n  activeRuleset:WalkRuleSet\n\n  save() : any {\n    return {\n      buff : this.buff,\n      i : this.i,\n      buffers: this.buffers,\n      walkRules: this.walkRules,\n      namedRulez : this.namedRulez,\n      rulez : this.rulez,\n      activeRuleset : this.activeRuleset,\n      buff_index : this.buff_index,\n      used_index : this.used_index,\n    }\n  }\n\n  restore( from:any ) {\n    this.buff = from.buff \n    this.i = from.i \n    this.buffers = from.buffers \n    this.walkRules = from.walkRules\n    this.namedRulez = from.namedRulez\n    this.rulez = from.rulez \n    this.activeRuleset = from.activeRuleset\n    this.buff_index = from.buff_index\n    this.used_index = from.used_index\n  }\n\n  constructor(initWith:string[]) {\n    this.buffers = initWith\n    this.buff = initWith[0]\n    this.i = 0\n    this.buff_index = 0\n    this.used_index = 0\n    this.eof = false\n    if(typeof(this.buff)==='undefined') this.eof = true\n  }\n\n  addRule (rule:WalkRule) {\n    this.walkRules.push(rule)\n  }\n\n  createDetector( list:string[]) : () => string | boolean {\n    const does_match = createDetector(list)\n    return () : string | boolean => {\n      const i = does_match( this.buff, this.i )\n      if( i>=0) {\n        const cnt = list[i].length\n        this.step(cnt)\n        return list[i]\n      }\n      return false\n    }\n  }\n\n  // The end criteria etc...\n  startEnd ( startCh:string, endCh:string ) {\n    \n    const is_start = this.createDetector([startCh])\n    const is_end = this.createDetector([endCh])\n    const is_paren_start = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    is_paren_start.exec = (buff) => {\n      if(is_start() !== false) {\n        const node = new ASTNode()\n        node.expression = true \n        return node\n      }\n    }\n    \n    const is_paren_end = WalkRule.create( (buff) => {\n      if(is_end() !== false) {\n        const node = new ASTNode()\n        node.end_expression = true \n        return node\n      }\n    })   \n    this.addRule( is_paren_start ) \n    this.addRule( is_paren_end ) \n  }\n\n  createRule ( fn:(buff:ParserBuffer) => ASTNode | undefined)  {\n    const rule = new WalkRule()    \n    rule.exec = fn \n    this.walkRules.push( rule )\n  }\n\n  // almost same as \"exec\"\n  walkRule( rule: WalkRule ) : ASTNode | undefined {\n\n    // also, the rule could be just a reference to a some subrule...\n\n    // just the simple rule execution...\n    const theNode = rule.exec(this)\n\n    // could the execute return also new rule ? \n    if(theNode instanceof WalkRule) {\n      return\n    }\n\n    if(rule.isRequired && !theNode) {\n      throw `Error parsing rule ${rule.name}`\n    }\n\n    // can you create another rule using the \"exec\" ???\n    // The rule has information if you should walk further...\n    /*\n    const rulez = new WalkRuleSet\n    rulez.walkRules = ruleset\n    endCondition.ruleset = rulez\n    endCondition.name = startCh\n    return endCondition      \n    */\n    \n    if(theNode && !theNode.nop) {      \n\n      if(rule.typeName) theNode.typeName = rule.typeName\n\n      // this node could be just ending the expression...\n      if(theNode.end_expression) return theNode      \n\n      // we have children maybe then...\n      if(theNode.expression) {\n\n        // here:\n        // 1. needs expression\n        // 2. the ruleset must define the rules which are used inside this expression\n\n        if(rule.ruleset) {\n          // 1. map the subrules based on the generator...\n          let list_of_rules = rule.ruleset.walkRules.map( r => {\n            return r.ruleGenerator ? r.ruleGenerator() : r\n          })    \n  \n          let res\n          let last_index = this.i\n          let not_found_cnt = 0\n          let exit_xpr = false\n          \n          // current op pred...\n          let active_op_pred = 9999\n\n          // the primary operator\n          let left_op = theNode\n          let right_op = null\n\n          let activeNode = theNode\n\n          // for the sub expression which may be created...\n          const node_stack = []\n\n          while(!this.eof && !exit_xpr) {\n            for(let rule of list_of_rules) {\n              // 3. Here, perhaps we should walk the subrule\n\n              // NOT:\n              // res = rule.exec(this)\n              res = this.walkRule( rule )\n              // if we get node, add it to the ASTNode created...\n              if( res instanceof ASTNode ) {\n                /*\n                  4               ( 4 )\n                  4 +             (+ 4)             \"op wants 1 more...\"\n                  4 + 5           (+ 4 5)           \"full operator\"\n                  4 + 5 *         (+ 4 (* 5))\n                  4 + 5 * 10      (+ 4 (* 5 10))\n\n                  4\n                  4 *\n                  4 * 5\n                  4 * 5 +\n                  4 * 5 + 10 \n\n\n                  */\n\n                if(res.operator_pred > 0 ) {\n                  console.log('FOUND OP', res, 'pred', res.operator_pred)\n                  // console.log('OP parent is ', theNode)\n                  console.log('active_pred',  active_op_pred) \n                  if(res.operator_assoc === 1 ) {\n\n                    if( active_op_pred < res.operator_pred) {\n                      console.log()\n                      // we have to create a new by stealing the last part from active...\n                      const last_ch = theNode.children.pop()\n                      const new_expr = new ASTNode()\n                      new_expr.expression = true \n                      new_expr.children.push( res )\n                      new_expr.children.push( last_ch )\n\n                      activeNode.children.push( new_expr )\n                      node_stack.push( activeNode )\n                      activeNode = new_expr\n\n                      active_op_pred = res.operator_pred\n                      continue\n\n                    } else {\n\n                    }\n                    // TODO: fix \n                    console.log('left-to-rigth assoc op')\n                    // simple, add this as first\n                    activeNode.children.unshift(res)\n                  }\n\n                  active_op_pred = res.operator_pred\n                  \n                  // has been managed using operator rules\n                  continue\n                }\n\n                if( res.end_expression ) {\n\n                  exit_xpr = true \n                  break\n                }\n\n                if(!rule.isSkipped) {\n                  // the res.name could be groupName for the AstNode\n                  if(res.name) {\n                    if(!activeNode.namedChildren[res.name]) activeNode.namedChildren[res.name] = []\n                    activeNode.namedChildren[res.name].push( res )\n                  } else {\n                    activeNode.children.push(res)\n                  }  \n                }\n                break  \n              }\n            }\n            if(last_index === this.i) {\n              // not finding anything ???\n              if( not_found_cnt++ > 0 ) break\n            } else {\n              not_found_cnt = 0\n            }\n            last_index = this.i      \n          }\n        }  \n      }\n    }\n    // this is the default behaviour... walk and return...\n    return theNode\n  }\n\n  /*\n  \n  The Walk should be refactored so that it can walk any Rule and return a node\n  or list of nodes\n\n  */\n\n  \n  walk(parentNode:ASTNode) {\n    if(!this.activeRuleset) {\n      throw 'Active ruleset not defined'\n    }\n    let last_i = this.i\n    let last_buff = this.buff\n\n    let list_of_rules = this.activeRuleset.walkRules.map( r => {\n      return r.ruleGenerator ? r.ruleGenerator() : r\n    })\n    while(!this.eof) {\n      last_i = this.i\n      last_buff = this.buff\n      let res = null\n      for(let rule of list_of_rules) {\n        res = rule.exec(this)\n        if(rule.isRequired && !res) {\n          throw `Error parsing rule ${rule.name}`\n        }\n        if(res && !res.nop) {\n          // walking the subrules etc...\n          if(res.end_expression) return\n          if(res.expression) {\n            // -- the rule matched, check if the rule has its own set of rules\n            let current_ruleset = this.activeRuleset\n            if(rule.ruleset) {\n              this.rulez.push( this.activeRuleset )\n              this.activeRuleset = rule.ruleset\n            }\n            // this approach is perhaps a bit less modular because it assumes\n            // the environment is setup at some way...\n            this.walk( res )\n            // then we exit the ruleset and continue...\n            if(rule.ruleset) {\n              this.rulez.pop( )\n              this.activeRuleset = current_ruleset\n            }            \n          }\n\n          // This is a bit strange, consider removing...\n          if(rule.typeName) res.typeName = rule.typeName\n\n          if(res.name) {\n            if(!parentNode.namedChildren[res.name]) parentNode.namedChildren[res.name] = []\n            parentNode.namedChildren[res.name].push( res )\n          } else {\n            parentNode.children.push(res)\n          }\n          break\n        }\n      }\n      if(last_i === this.i && last_buff === this.buff) {\n        // maybe rise error? could not match\n        console.log('--- rules --- ')\n        console.log(list_of_rules)\n        throw 'Parser could not apply rules to the whole buffer at ' + this.buff.substring(this.i)\n      }    \n    }\n  }\n\n  code ( index:number ) : number {\n    if( typeof(this.buff) != 'string' ) {\n      return 0\n    }\n    if(this.buff.length <= this.i + index ) {\n      const next = this.buffers[this.buff_index + 1]\n      if(typeof(next) != 'string') {\n        return 0\n      }\n      if(next) {\n        return next.charCodeAt( this.i + index - this.buff.length )\n      }\n      return 0\n    }        \n    return this.buff.charCodeAt( this.i + index )\n  }\n\n  here () : number {\n    if(typeof(this.buff) != 'string') return 0\n    return this.buff.charCodeAt( this.i )\n  }\n\n  isHere ( value:number | detectorFn) : boolean {\n    if(typeof(value) === 'function') {\n      return value(this.buff, this.i ) >= 0\n    }\n    return this.buff.charCodeAt( this.i ) == value\n  }  \n\n  whatIsHere ( value: detectorFn) : number {\n    return value(this.buff, this.i )\n  }    \n\n  step ( index:number ) : number {\n    this.i += index\n    this.used_index = this.buff_index\n    if(this.buff.length <= this.i ) {\n      this.i = this.i - this.buff.length\n      this.buff_index = this.buff_index + 1\n      this.used_index = this.buff_index\n      this.buff = this.buffers[ this.buff_index ]\n      if(typeof(this.buff) === 'undefined') {\n        this.eof = true\n        return 0\n      } else {\n        return this.buff.charCodeAt(0)\n      }\n    }\n    return this.buff.charCodeAt(this.i)\n  }   \n\n  stepBuffer() {\n    this.buff_index = this.buff_index + 1\n    this.used_index = this.buff_index\n    this.buff = this.buffers[ this.buff_index ]\n    this.i = 0\n    if(typeof(this.buff) === 'undefined') {\n      this.eof = true\n    }   \n  }\n\n  getWhile( fn:(buff:ParserBuffer) => boolean) : ASTNode | undefined { \n    let any_node:ASTNode\n    let c = this.here()\n    while(!this.eof) {\n      if( !fn(this) ) return any_node;\n      c = this.step(1)\n      if(!any_node) {\n        // the filename should be perhapce marked at the position, OR it could\n        // be part of the AST tree ? \n        any_node = new ASTNode()\n        any_node.buff = this.buff\n        any_node.sp = this.i-1\n        any_node.ep = this.i\n      } else {\n        any_node.ep = this.i\n      }\n    }\n    return any_node\n  }   \n\n  getSpace() : ASTNode | undefined { \n    let spacenode:ASTNode\n    let c = this.here()\n    while(!this.eof) {\n      if( c > 32 ) return spacenode;\n      c = this.step(1)\n      if(!spacenode) {\n        // the filename should be perhapce marked at the position, OR it could\n        // be part of the AST tree ? \n        spacenode = new ASTNode()\n        spacenode.buff = this.buff\n        spacenode.sp = this.i -1\n        spacenode.ep = this.i\n      } else {\n        spacenode.ep = this.i\n      }\n    }\n    return spacenode\n  }  \n\n  skipspace() : boolean { \n    let had_space = false\n    let c = this.here()\n    while(!this.eof) {\n      if( c > 32 ) break;\n      c = this.step(1)\n      had_space = true\n    }\n    return had_space\n  }\n\n  // for detecting XML tag chars, not really useful as generic function\n  isTagChar( c:number, first:boolean ) {\n    return (    ((c >= 65) && (c <= 90))     // A - Z\n    || ((c >= 97) && (c <= 122))    // a - z\n    || ( c == 95)                   // _\n    || ( c == 58)                   // :\n    || (!first && (c >= 48) && (c <= 57))     // 0 - 9\n    || (!first && c == 46)          // .\n    || (!first && c == 45)          // -\n   )\n  }\n\n  // collects a name like div or attribute name ( a bit simplified version )\n  collectXMLName () : string {\n    let sp = this.i;\n    let c = this.here()\n    let first = true\n    const start_buff = this.buff\n    while( !this.eof && this.isTagChar( c, first) ) {\n      c = this.step(1)\n      first = false\n    }\n    if(start_buff == this.buff) {\n      return this.buff.substring( sp, this.i )\n    }\n    return start_buff.substring( sp ) + this.buff.substring( 0, this.i )\n  } \n\n  skipUntil (fn) {\n    let curr_buff = this.buff\n    while( (false === fn(this.buff,this.i)) && !this.eof ) {\n      this.step(1)\n    }\n  }    \n\n  collectUntil (value) : string {\n    let sp = this.i;\n    let c = this.here()\n    const start_buff = this.buff\n    let curr_buff = this.buff\n    const intermediate = []\n    while( c != value && !this.eof ) {\n      c = this.step(1)\n      if(curr_buff != this.buff) {\n        intermediate.push(this.buff)\n      }\n      curr_buff = this.buff\n    }\n    if(start_buff == this.buff) {\n      return this.buff.substring( sp, this.i )\n    }\n    intermediate.pop() // remove last intermediate because it is this.buff\n    return start_buff.substring( sp ) + intermediate.join('') + this.buff.substring( 0, this.i )\n  }   \n}"]}