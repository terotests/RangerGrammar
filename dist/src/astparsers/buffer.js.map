{"version":3,"file":"buffer.js","sourceRoot":"","sources":["../../../src/astparsers/buffer.ts"],"names":[],"mappings":"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","sourcesContent":["\n/*\n\nBuffer is created for parsing streams of values and strings.\n\n*/\n\nimport {detectorFn, createDetector} from './detector'\nimport { ASTNode } from '../ast/ast';\n\nexport type bufferType = string \n\n\nexport class WalkCmd {\n\n  // does this command end the expression?\n  end_expression = false\n  \n  // These could be properties of the node\n  is_expression = false\n  is_block = false\n\n  node:ASTNode\n}\n\n// how to create language rules\nexport class WalkRule {\n  name = ''\n  scopeName = ''\n  callback : (rulename:string, buff:ParserBuffer, stepLen:number) => void\n  exec : (buff:ParserBuffer) => ASTNode | undefined\n\n  // if set the rule is constructed using this function\n  ruleGenerator : () => WalkRule | undefined\n\n  ruleset : WalkRuleSet\n\n  static create( fn:(buff:ParserBuffer) => ASTNode | undefined ) : WalkRule {\n    const n = new WalkRule()\n    n.exec = fn\n    return n\n  }\n\n  static generator( fn:() => WalkRule ) : WalkRule {\n    const n = new WalkRule()\n    n.ruleGenerator = fn\n    return n\n  }  \n\n  static createSub( \n      fn:(buff:ParserBuffer) => ASTNode | undefined,\n      ruleset : WalkRuleSet \n    ) : WalkRule {\n    const n = new WalkRule()\n    n.ruleset = ruleset\n    n.exec = fn\n    return n\n  }\n\n  static createEnterRule( startCh:string, ruleset:WalkRule[] ) : WalkRule {\n\n    const does_match = createDetector([startCh])    \n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i)\n      if(i >= 0) {\n        buff.step(startCh.length)\n        const node = new ASTNode()\n        node.expression_name = startCh\n        node.expression = true \n        return node\n      }\n    }\n    const rulez = new WalkRuleSet\n    rulez.walkRules = ruleset\n    endCondition.ruleset = rulez\n    return endCondition    \n  }  \n\n  static createExit() : WalkRule {\n\n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      // exit in any case\n      const node = new ASTNode()\n      node.end_expression = true \n      return node\n    }\n    return endCondition\n  }   \n\n  static createExitRule( endCh:string ) : WalkRule {\n\n    const does_match = createDetector([endCh])    \n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i)\n      if(i >= 0) {\n        buff.step(endCh.length)\n        const node = new ASTNode()\n        node.end_expression = true \n        return node\n      }\n    }\n    return endCondition\n  }    \n\n  static createTokenRules( list:string[] ) : WalkRule {\n\n    const does_match = createDetector(list)    \n    const endCondition = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    endCondition.exec = (buff) => {\n      const i = does_match( buff.buff, buff.i)\n      if(i >= 0) {\n        // Token node...\n        const node = new ASTNode()\n        node.sp = buff.i \n        node.ep = buff.i + list[i].length\n        node.buff = buff.buff\n        buff.step(list[i].length)\n        return node\n      }\n    }\n    return endCondition\n  }   \n\n}\n\n// Some rules to apply in ceratain conditions...\nexport class WalkRuleSet {\n  name = ''\n  walkRules:WalkRule[] = []\n  static create( name: string, rules:WalkRule[]) : WalkRuleSet {\n    const o = new WalkRuleSet()\n    o.name = name\n    o.walkRules = rules\n    return o\n  }\n}\n\nexport class ParserBuffer  {\n\n  __len = 0\n  buff_index = 0\n  used_index = 0\n\n  // the current buffer and the index inside it\n  buff:bufferType\n  i = 0\n  eof = false\n\n  buffers:bufferType[]\n  last_finished = null\n\n  in_tagdef = false\n  is_selfclosing = false\n  last_tag_name = ''\n\n  // what is the rulez scope we are walking right now...\n  scopes:string[]\n\n  // The current ruleset to be applied...\n  walkRules:WalkRule[] = []\n\n  // Named rules\n  namedRulez:{[key:string]:WalkRuleSet} = {}\n\n  // What is the ruleset to use...\n  rulez:WalkRuleSet[] = []\n\n  // Active ruleset...\n  activeRule:WalkRuleSet\n\n  constructor(initWith:string[]) {\n    this.buffers = initWith\n    this.buff = initWith[0]\n    this.i = 0\n    this.buff_index = 0\n    this.used_index = 0\n    this.eof = false\n    if(typeof(this.buff)==='undefined') this.eof = true\n  }\n\n  addRule (rule:WalkRule) {\n    this.walkRules.push(rule)\n  }\n\n  createDetector( list:string[]) : () => string | boolean {\n    const does_match = createDetector(list)\n    return () : string | boolean => {\n      const i = does_match( this.buff, this.i )\n      if( i>=0) {\n        const cnt = list[i].length\n        this.step(cnt)\n        return list[i]\n      }\n      return false\n    }\n  }\n\n  // The end criteria etc...\n  startEnd ( startCh:string, endCh:string ) {\n    \n    const is_start = this.createDetector([startCh])\n    const is_end = this.createDetector([endCh])\n    const is_paren_start = new WalkRule();\n\n    // How can you evaluate the buffer using the new reuleset ? \n    is_paren_start.exec = (buff) => {\n      if(is_start() !== false) {\n        const node = new ASTNode()\n        node.expression = true \n        return node\n      }\n    }\n    \n    const is_paren_end = WalkRule.create( (buff) => {\n      if(is_end() !== false) {\n        const node = new ASTNode()\n        node.end_expression = true \n        return node\n      }\n    })   \n    this.addRule( is_paren_start ) \n    this.addRule( is_paren_end ) \n  }\n\n  createRule ( fn:(buff:ParserBuffer) => ASTNode | undefined)  {\n    const rule = new WalkRule()    \n    rule.exec = fn \n    this.walkRules.push( rule )\n  }\n\n  walk(parentNode:ASTNode) {\n    if(!this.activeRule) {\n      throw 'Active ruleset not defined'\n    }\n    let last_i = this.i\n    let last_buff = this.buff\n\n    let list_of_rules = this.activeRule.walkRules.map( r => {\n      return r.ruleGenerator ? r.ruleGenerator() : r\n    })\n    while(!this.eof) {\n      last_i = this.i\n      last_buff = this.buff\n      for(let rule of list_of_rules) {\n        const res = rule.exec(this)\n        if(res) {\n          if(res.end_expression) return\n          if(res.expression) {\n            // -- the rule matched, check if the rule has its own set of rules\n            let current_ruleset = this.activeRule\n            if(rule.ruleset) {\n              this.rulez.push( this.activeRule )\n              this.activeRule = rule.ruleset\n            }\n            this.walk( res )\n            // then we exit the ruleset and continue...\n            if(rule.ruleset) {\n              this.rulez.pop( )\n              this.activeRule = current_ruleset\n            }            \n          }\n          if(res.name) {\n            if(!parentNode.namedChildren[res.name]) parentNode.namedChildren[res.name] = []\n            parentNode.namedChildren[res.name].push( res )\n          } else {\n            parentNode.children.push(res)\n          }\n          break\n        }\n      }\n      if(last_i === this.i && last_buff === this.buff) {\n        // maybe rise error? could not match\n        throw 'Parser could not apply rules to the whole buffer'\n      }\n    }\n  }\n\n  code ( index:number ) : number {\n    if( typeof(this.buff) != 'string' ) {\n      return 0\n    }\n    if(this.buff.length <= this.i + index ) {\n      const next = this.buffers[this.buff_index + 1]\n      if(typeof(next) != 'string') {\n        return 0\n      }\n      if(next) {\n        return next.charCodeAt( this.i + index - this.buff.length )\n      }\n      return 0\n    }        \n    return this.buff.charCodeAt( this.i + index )\n  }\n\n  here () : number {\n    if(typeof(this.buff) != 'string') return 0\n    return this.buff.charCodeAt( this.i )\n  }\n\n  isHere ( value:number | detectorFn) : boolean {\n    if(typeof(value) === 'function') {\n      return value(this.buff, this.i ) >= 0\n    }\n    return this.buff.charCodeAt( this.i ) == value\n  }  \n\n  whatIsHere ( value: detectorFn) : number {\n    return value(this.buff, this.i )\n  }    \n\n  step ( index:number ) : number {\n    this.i += index\n    this.used_index = this.buff_index\n    if(this.buff.length <= this.i ) {\n      this.i = this.i - this.buff.length\n      this.buff_index = this.buff_index + 1\n      this.used_index = this.buff_index\n      this.buff = this.buffers[ this.buff_index ]\n      if(typeof(this.buff) === 'undefined') {\n        this.eof = true\n        return 0\n      } else {\n        return this.buff.charCodeAt(0)\n      }\n    }\n    return this.buff.charCodeAt(this.i)\n  }   \n\n  stepBuffer() {\n    this.buff_index = this.buff_index + 1\n    this.used_index = this.buff_index\n    this.buff = this.buffers[ this.buff_index ]\n    this.i = 0\n    if(typeof(this.buff) === 'undefined') {\n      this.eof = true\n    }   \n  }\n\n  getWhile( fn:(buff:ParserBuffer) => boolean) : ASTNode | undefined { \n    let any_node:ASTNode\n    let c = this.here()\n    while(!this.eof) {\n      if( !fn(this) ) return any_node;\n      c = this.step(1)\n      if(!any_node) {\n        // the filename should be perhapce marked at the position, OR it could\n        // be part of the AST tree ? \n        any_node = new ASTNode()\n        any_node.buff = this.buff\n        any_node.sp = this.i-1\n        any_node.ep = this.i\n      } else {\n        any_node.ep = this.i\n      }\n    }\n    return any_node\n  }   \n\n  getSpace() : ASTNode | undefined { \n    let spacenode:ASTNode\n    let c = this.here()\n    while(!this.eof) {\n      if( c > 32 ) return spacenode;\n      c = this.step(1)\n      if(!spacenode) {\n        // the filename should be perhapce marked at the position, OR it could\n        // be part of the AST tree ? \n        spacenode = new ASTNode()\n        spacenode.buff = this.buff\n        spacenode.sp = this.i -1\n        spacenode.ep = this.i\n      } else {\n        spacenode.ep = this.i\n      }\n    }\n    return spacenode\n  }  \n\n  skipspace() : boolean { \n    let had_space = false\n    let c = this.here()\n    while(!this.eof) {\n      if( c > 32 ) break;\n      c = this.step(1)\n      had_space = true\n    }\n    return had_space\n  }\n\n  // for detecting XML tag chars, not really useful as generic function\n  isTagChar( c:number, first:boolean ) {\n    return (    ((c >= 65) && (c <= 90))     // A - Z\n    || ((c >= 97) && (c <= 122))    // a - z\n    || ( c == 95)                   // _\n    || ( c == 58)                   // :\n    || (!first && (c >= 48) && (c <= 57))     // 0 - 9\n    || (!first && c == 46)          // .\n    || (!first && c == 45)          // -\n   )\n  }\n\n  // collects a name like div or attribute name ( a bit simplified version )\n  collectXMLName () : string {\n    let sp = this.i;\n    let c = this.here()\n    let first = true\n    const start_buff = this.buff\n    while( !this.eof && this.isTagChar( c, first) ) {\n      c = this.step(1)\n      first = false\n    }\n    if(start_buff == this.buff) {\n      return this.buff.substring( sp, this.i )\n    }\n    return start_buff.substring( sp ) + this.buff.substring( 0, this.i )\n  } \n\n  skipUntil (fn) {\n    let curr_buff = this.buff\n    while( (false === fn(this.buff,this.i)) && !this.eof ) {\n      this.step(1)\n    }\n  }    \n\n  collectUntil (value) : string {\n    let sp = this.i;\n    let c = this.here()\n    const start_buff = this.buff\n    let curr_buff = this.buff\n    const intermediate = []\n    while( c != value && !this.eof ) {\n      c = this.step(1)\n      if(curr_buff != this.buff) {\n        intermediate.push(this.buff)\n      }\n      curr_buff = this.buff\n    }\n    if(start_buff == this.buff) {\n      return this.buff.substring( sp, this.i )\n    }\n    intermediate.pop() // remove last intermediate because it is this.buff\n    return start_buff.substring( sp ) + intermediate.join('') + this.buff.substring( 0, this.i )\n  }   \n}"]}