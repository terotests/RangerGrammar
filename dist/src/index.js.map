{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport { WalkRule, WalkRuleSet, ParsingRule } from './rules/walker'\nimport { ParserBuffer } from './astparsers/buffer'\nimport {detectorFn, createDetector} from './astparsers/detector'\nimport { ASTNode } from './ast/ast';\n\nconsole.log('HEllo')\n\nconst equal_signs = [\n  '<', '>', '===', '==', '<=', '>='\n]\nconst statements = [\n  'for', 'while', 'if','then'\n]\nconst keywords = [\n  'class', 'function', 'extends', 'static'\n]\n\n/*\nif( x > 0 ) {\n\n}\n--> add callback for something...\nTODO: \n- think if the comparator can be used generically\n*/\n\n// The Infix logic is quite simple actually...\n// https://github.com/terotests/Ranger/blob/master/compiler/ng_parser_v2.clj#L1146-L1223\n\n\n// add rules to the ...\n\nconst isComparator = createDetector(equal_signs)\nconst isStatement = createDetector(statements)\nconst isKeyword = createDetector(keywords)\n\n//\nconst buff2 = new ParserBuffer([`\n\n  SELECT name FROM foobar;\n\n  for while 22 ( 4*4*19/2)\n  begin\n   3 4 5  what\n  end\n\n  class normalClass\n\n  class lolcatz\n\n  class foobar  {\n    717\n  }\n\n  static class foob {\n\n  }\n\n  class someotherClass\n  class myClass\n\n  class abba extends someclass {\n    This is the class Defintion\n  }\n\n`])\n\nconst buff = new ParserBuffer([`\n  class normalClass\n`])\n\n/*\n\nInstructions for the parser\n\n1. push new expression into the parser stack\n2. unwind expressions and continue\n\n*/\n\nconst is_space = new WalkRule()\nis_space.exec = buff => buff.getSpace()\n\n// This rule is still wrong...\nconst is_any = new WalkRule()\nis_any.exec = buff => buff.getWhile( buff => {\n  const c = buff.here()\n  const A = 'A'.charCodeAt(0)\n  const z = 'z'.charCodeAt(0)\n  return (c >= A) && (c <= z)\n})\n\nconst is_valid_identifier = new WalkRule()\nis_valid_identifier.exec = buff => {\n  \n  // identifier can not be a keyword...\n  if(isKeyword(buff.buff, buff.i) >= 0) return\n\n  return buff.getWhile( buff => {\n    const c = buff.here()\n    const A = 'A'.charCodeAt(0)\n    const z = 'z'.charCodeAt(0)\n    return (c >= A) && (c <= z)\n  })\n}\n\n// parsing a number...\nconst is_numeric = new WalkRule()\nis_numeric.exec = buff => buff.getWhile( buff => {\n  const c = buff.here()\n  const zero = '0'.charCodeAt(0)\n  const nine = '9'.charCodeAt(0)\n  return (c >= zero) && (c <= nine)\n})\n\n// the exec should be able to return...\n/*\n\nbegin\n  \nend\n\n*/\n\nconst is_paren_start = new WalkRule();\nis_paren_start.exec = (buff) => {\n  if(buff.here() == '('.charCodeAt(0)) {\n    buff.step(1)\n    const node = new ASTNode()\n    node.expression = true \n    return node\n  }\n}\n\n// **** how to create start and end blocks ***\n/*\n\nconst is_paren_end = new WalkRule()\nis_paren_end.exec = (buff) => {\n  if(buff.here() == ')'.charCodeAt(0)) {\n    buff.step(1)\n    const node = new ASTNode()\n    node.end_expression = true \n    return node\n  }\n}\n*/\n\n\nconst is_comp = new WalkRule()\nis_comp.exec = buff => buff.getWhile( buff => buff.here() == '<'.charCodeAt(0) )\n\nconst is_plus = WalkRule.create(  buff => buff.getWhile( buff => buff.here() == '+'.charCodeAt(0) ) )\n\n// Two rules...\n/*\n\n   \n*/\n\n// ---> the basic ruleset...\n\nlet rule_class;\n\nconst startRule = WalkRuleSet.create('std', \n  [\n    is_space,\n    is_numeric,\n\n    // 1. rule can be simple push as child rule\n    // 2. rule can be named rule\n    // 3. name rule with multiple instances..\n\n    // 4. a the ruleset could also be run only once...\n\n    \n    WalkRule.try(WalkRule.createEnterRule('class', \n    [\n      // maybe some ordered state which is created when you enter this...\n      // function which creates the state function ? \n      // first you consume name, then optional args, then body\n      // finally you exit the conditional parser...\n      is_space,\n      WalkRule.fail(),\n      WalkRule.rule({\n        maxCnt : 1,\n        required : true,\n        matchName : 'classN',\n        walkRule : WalkRule.createTokenRules(['lolcatz'])\n      }),      \n      WalkRule.createExit()\n    ])),\n    \n    rule_class = WalkRule.createEnterRule('class', \n    [\n      // maybe some ordered state which is created when you enter this...\n      // function which creates the state function ? \n      // first you consume name, then optional args, then body\n      // finally you exit the conditional parser...\n\n      is_space,\n      WalkRule.rule({\n        maxCnt : 1,\n        matchName : 'classN',\n        walkRule : is_valid_identifier\n      }),\n      // class X extends Y\n      WalkRule.createEnterRule('extends', \n      [\n        is_space,\n        // extra rule for this condition...\n        WalkRule.rule({\n          maxCnt : 2,\n          matchName : 'lol',\n          walkRule : WalkRule.createTokenRules(['lolz'])\n        }),        \n        WalkRule.rule({\n          maxCnt : 1,\n          required : true,\n          matchName : 'className',\n          walkRule : is_valid_identifier\n        }),        \n        WalkRule.createExit()\n      ]),\n      /*\n      WalkRule.generator( () => {\n        // Example of rule which matches only once...\n        let cnt = 0\n        return WalkRule.create( (buff) => {\n          const matches = is_valid_identifier.exec(buff);\n          if( matches ) {\n            if(cnt++ > 0) {\n              throw 'Can not match two identifiers at class!!! ' + buff.buff.substring( buff.i )\n            }\n            // and set the name for the element...\n            matches.name = 'className'\n            return matches  \n          }\n        })\n      }),\n      */\n      // collect this rule into special variable name 'classBody'\n      WalkRule.createEnterRule('{', [\n        is_space,\n        is_numeric,\n        is_any,\n        WalkRule.createExitRule('}')\n      ]),      \n      WalkRule.createExit(),\n      // exits if nothing matches...\n    ]), \n\n    WalkRule.createEnterRule('static', [\n      is_space,\n      // example guard which stops the expression if evaluated many times\n      WalkRule.once(),\n      WalkRule.createEnterRule('class', \n      [\n        is_space,\n        WalkRule.rule({\n          maxCnt : 1,\n          matchName : 'classN',\n          walkRule : is_valid_identifier\n        }),\n        // class X extends Y\n        WalkRule.createEnterRule('extends', \n        [\n          is_space,\n          // extra rule for this condition...\n          WalkRule.rule({\n            maxCnt : 2,\n            matchName : 'lol',\n            walkRule : WalkRule.createTokenRules(['lolz'])\n          }),        \n          WalkRule.rule({\n            maxCnt : 1,\n            required : true,\n            matchName : 'className',\n            walkRule : is_valid_identifier\n          }),        \n          WalkRule.createExit()\n        ]),\n        // collect this rule into special variable name 'classBody'\n        WalkRule.createEnterRule('{', [\n          is_space,\n          is_numeric,\n          is_any,\n          WalkRule.createExitRule('}')\n        ]),      \n        WalkRule.createExit(),\n        // exits if nothing matches...\n      ])\n    ]), \n    \n    // Testing SELECT + other SQL rules\n    WalkRule.createEnterRule('SELECT', [\n      is_space,\n      is_numeric,\n      is_any,\n      WalkRule.createTokenRules(['+', '-', '*', '/']),\n      WalkRule.createExitRule(';')\n    ]),    \n    \n    // ? how to model <div attr=\"foobar\" attr2=\"foobar2\"></div>\n    // collect items into namespaces...\n    WalkRule.createEnterRule('(', [\n      is_space,\n      is_numeric,\n      WalkRule.createTokenRules(['+', '-', '*', '/']),\n      WalkRule.createExitRule(')')\n    ]),\n\n    WalkRule.createEnterRule('begin', [\n      is_space,\n      is_numeric,\n      WalkRule.createExitRule('end'),\n      is_any,\n      WalkRule.createTokenRules(['+', '-', '*', '/', ')', '(']),\n      \n    ]),\n    is_any    \n  ]\n)\n\n/*\nbuff.addRule( is_space )\nbuff.startEnd('(', ')')\nbuff.startEnd('begin', 'end')\n\n//buff.addRule( is_paren_start )\n//buff.addRule( is_paren_end )\n\nbuff.addRule( is_numeric )\nbuff.addRule( is_comp )\nbuff.addRule( is_plus )\nbuff.addRule( is_any )\n*/\nbuff.activeRuleset = startRule\n\nconst parentNode = new ASTNode()\n\nbuff.walk( parentNode )\n\nparentNode.children.forEach( (ch,i) => {\n  console.log(ch.getCodeString())\n})\n\n/*\nconsole.log(buff.whatIsHere(isFor))\n\nif(buff.here() === 'f'.charCodeAt(0)) {\n  console.log('First Char is F')\n}\nbuff.step(1)\n\nif(buff.here() === 'o'.charCodeAt(0)) {\n  console.log('Second Char is o')\n}\nbuff.step(3)\n\nconsole.log(buff.whatIsHere(isFor))\n*/\n\n\n\n\n\n"]}